#!/usr/bin/env python

# A tiny CGI server

from BaseHTTPServer import HTTPServer
from CGIHTTPServer import CGIHTTPRequestHandler
from SocketServer import ForkingMixIn
import sys, os, subprocess

# Subclass CGIHTTPRequestHandler to serve programs named xxx.cgi in the current
# directory as CGIs. 
#
# HTTP query params are given as command line arguments, and posted data is
# passed on stdin.  
#
# If the script has a non-zero exit code, the returns status "500 Error %d: s",
# otherwise returns status "200 OK"
#
# In either case the script stderr/stdout is returned as Content-Type:
# text/plain. 
class cgihandler(CGIHTTPRequestHandler):
    # force every request through run_cgi   
    def is_cgi(self): return True

    def run_cgi(self):
        cmd, _, args = self.path[1:].partition('?')
        # append .cgi if needed
        if not cmd.endswith('.cgi'): cmd += '.cgi'                

        # it must be in the current directory
        if cmd.find('/') >= 0 or not os.path.isfile(cmd): 
            self.send_error(403, "No such command '%s'" % cmd)
            return

        # split the args on '&' and then replace '+' with space    
        # XXX this is simplistic
        args = [a.replace('+',' ') for a in args.split('&')]
        command=[cmd, *args]

        self.log_message("Running ",command)
        input = None
        if self.command.lower() == "post":
            # slurp up post data 
            try:
                length = int(self.headers.getheader('content-length'))
                if length > 0: input = self.rfile.read(length)
            except:
                self.send_error(403, "Invalid POST input")
        
        # flush unexpected input
        while select.select([self.rfile._sock], [], [], 0)[0]:
            if not self.rfile._sock.recv(1):
                break

        # ok do it
        p = subprocess.Popen(command, stdin = subprocess.PIPE, stdout = subprocess.PIPE,   stderr = subprocess.STDOUT, env = os.environ)
        output = p.communicate(data).strip()
        status = p.returncode
        p.stdout.close()
        if status:
            self.log_error("CGI exit status %d" % status)
            self.send_response(500, "Exit status %d" % status)
            self.send_header("Content-type: text/plain");
            self.end_headers()
            self.wfile.write(stdout)
            if stderr: self.wfile.write("stderr:\r\n",stderr)
            self.wfile.write(stderr)
            return
        self.log_message("CGI exit OK") 
        self.send_response(200, "Script output follows")
        self.send_header("Content-type: text/plain");
        self.end_headers()
        self.wfile.write(stdout)

# Fork connections
class httpserver(ForkingMixIn,HTTPServer): pass

def start(chroot=None, port=8000, functions=None):
    for v in [k for k in os.environ]: del os.environ[v]     # purge environment
    os.chdir(chroot)                                        # change to directory
    httpserver(('',port),cgihandler).serve_forever()        # start

if __name__ == "__main__":
    usage = """
Usage:

    cgiserver directory [port] [2> logfile]

Serve scripts in specified directory as CGIs.  The script sees query params are
command line arguments and posted data is passed on stdin.  If port is not
specified, use port 8000.

CGIs must be executable and have the ".cgi" extension. The ".cgi" will be appended to
all queries if necessary.

Logs to stderr, redirect as needed. 
"""
    chroot = sys.argv[1]
    port = int(*sys.argv[2:3] or 8000)
    start(chroot, port)

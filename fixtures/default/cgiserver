#!/usr/bin/env python

# A tiny CGI server

# Subclass CGITTPREquestHandler to properly return "Status: XXX" headers or
# status 500 if a cgi script has non-zero exit status or writes to stderr
from __future__ import print_function
import BaseHTTPServer
from CGIHTTPServer import CGIHTTPRequestHandler
from cStringIO import StringIO
import sys, os, getopt, re

here=os.path.abspath(os.path.dirname(__file__))

# die with a message
def die(format, *args):
    sys.stderr.write((format+"\r\n") % args)
    sys.exit(1)

class cgihandler(CGIHTTPRequestHandler):
    have_fork = False # force run_cgi to use a subprocess

    # no special treatment for *.py
    def is_python(self, path):
        return False

    def is_cgi(self):
        # we only support cgi's, make sure it has .cgi extgension (if file
        # doesn't exist then the request will fail later)
        a, b, c = self.path[1:].partition('?') # first path char is '/'
        if not a.endswith(".cgi"): a+=".cgi"
        self.cgi_info = ('', a+b+c)
        return True

    # swallow logs if quiet
    def log_message(self, format, *args):
        if not self.quiet:
            CGIHTTPRequestHandler.log_message(self, format, *args)

    # remember first log_error, so stderr output error has priority over exit code
    def log_error(self, format, *args):
        if self.logged is None:
            self.logged=(format%args).strip()
        self.log_message(self, format, *args)

    def run_cgi(self):
        self.wsave=self.wfile                       # replace output file with stringIO
        self.wfile=StringIO()
        self.logged=None                            # assume no errors will be logged
        CGIHTTPRequestHandler.run_cgi(self)
        self.wfile.seek(0)
        status=self.wfile.readline()                # get status line
        rewind=self.wfile.tell()                    # remember rewind position
        if status.split(' ')[1].strip() == '200':   # if 'normal' exit
            if self.logged is not None:
                # run_cgi invoked log_error, return as status 500
                status='%s 500 %s\r\n' % (self.protocol_version, self.logged)
            else:
                # scan headers
                for line in self.wfile:
                    if line.strip() == '':
                        # end of headers
                        break
                    if not re.match('^\S+:.*\S',line):
                        # require form 'key: value'
                        status=self.protocol_version + ' 500 malformed header\r\n'
                        break;
                    if line.startswith('Status:'):
                        # if 'Status: something', use it
                        status='%s %s\r\n' % (self.protocol_version, line.split(':',1)[1].strip())

        self.wsave.write(status)
        self.wsave.write(self.wfile.getvalue())
        self.wfile.close()
        self.wfile=self.wsave

# parse options
try:
    opts, args = getopt.getopt(sys.argv[1:],'p:b:l')
    assert len(args)==0
except:
    die("""Usage:

    cgiserver [options]

Serve cgi scripts via http. Options are:

    -p port         - listen on specified port, instead of 8000
    -l              - log everything to stdout

CGI scripts must be in the same directory, with ".cgi" extension.
""")

cgihandler.quiet=True

port=8000
for opt, arg in opts:
    if opt == '-p':
        try:
            port = int(arg)
            assert 0 < port < 65536
        except:
            die("Invalid port '%s'", arg)

    if opt == '-l': cgihandler.quiet=False

# delete environment
for v in [k for k in os.environ]:
    del os.environ[v]

if not cgihandler.quiet: print("Serving %s on port %d..." % (here,port))

BaseHTTPServer.HTTPServer(("",port),cgihandler).serve_forever()
